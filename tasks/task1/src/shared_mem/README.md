# Доступ к разделяемому ресурсу

- Проблема гонки: одновременная запись/чтение без синхронизации приводит к неконсистентным данным.
- Мьютексы: защищают критические секции, правило — как можно короче держите блокировку.
- Семафоры: счетные (N ресурсов) и двоичные (0/1); `sem_wait` — уменьшить, `sem_post` — увеличить.
- Условные переменные: синхронизация по событиям; всегда использовать с мьютексом, цикл ожидания — `while`.
- Producer-Consumer: два состояния (пусто/полно) или буфер; правильная сигнализация предотвращает спуриации и дедлоки.

## Память и порядок

- Использование мьютекса обеспечивает не только взаимное исключение, но и упорядочивание операций (happens-before) между потоками.
- Не полагайтесь на `volatile` для синхронизации: он не гарантирует атомарности и порядка, используйте мьютексы/атомики.

## Дедлоки, livelock, starvation

- Дедлок: взаимная блокировка — избегайте циклов захвата, используйте единый порядок блокировок (lock ordering).
- Livelock: потоки постоянно "уступают", но прогресса нет — ограничивайте ретраи, добавляйте экспоненциальную паузу.
- Starvation: поток не получает ресурса — учитывайте справедливость, по возможности применяйте честные очереди.

## Рекомендации

- Делайте критические секции короткими и предсказуемыми.
- Никогда не вызывайте блокирующий ввод/вывод (или долгое вычисление) под мьютексом.
- Ясно документируйте, какой мьютекс защищает какое состояние.

Практика:

- `nomutex.c` — демонстрация проблемы без синхронизации.

Код демонстрирует гонку данных\
Гонка данных возникает, когда несколько потоков одновременно обращаются к общим данным и хотя бы один из потоков выполняет запись. Без синхронизации это приводит к непредсказуемому поведению и повреждению данных.
Механизмы синхронизации
-Мьютексы (mutual exclusion) - обеспечивают взаимное исключение, позволяя только одному потоку выполнять критическую секцию
-Критическая секция - часть кода, в которой происходит доступ к разделяемым ресурсам
- Атомарность - свойство операций выполняться полностью либо не выполняться вовсе.\
Вывод:
[![nomutex.png](https://i.postimg.cc/k4SDp1rB/nomutex.png)](https://postimg.cc/Q9XXBqd3)

Пример как работает рассинхронизация:
Операция var1++ состоит из трех шагов:
1. Прочитать значение из памяти
2. Увеличить его на 1
3. Записать обратно\
Между шагами система может переключиться на другой поток. Например:
- Поток 1: увеличил var1 (100 → 101)
- Переключились на поток 2
- Поток 2: видит var1=101, но var2 еще=100
- Возникает рассинхронизация\
\
На скриншоте видно что итоговые значения var1 и var2 отличаются. Их разница это - количество раз, когда потоки обнаружили, что переменные var1 и var2 не равны. Каждое такое обнаружение соответствует одному конкретному случаю гонки данных.\
Мы решали нашу проблему с помощью Мьютексов.

- `mutex.c` — выполнить студенту: защитить var1/var2 с мьютексом.

Вывод:

[![mutex.png](https://i.postimg.cc/HkSJc845/mutex.png)](https://postimg.cc/k2bML4HX)

- `semex.c` — пример счетного семафора для пробуждения потребителей.

Семафор - это механизм синхронизации, который управляет доступом к общему ресурсу через счетчик. В отличие от мьютекса (который бинарный), семафор может разрешать доступ нескольким потокам одновременно.

[![semex.png](https://i.postimg.cc/L5B5HJ84/semex.png)](https://postimg.cc/4HysPNcj)

- `condvar.c` — двухсостоятая машина.

До изменений:
[![condvar.png](https://i.postimg.cc/PrQvHRCF/condvar.png)](https://postimg.cc/XpXYcxcw)
Необходимо расширить двухсостоявную машину до четырехсостоявной с следующими переходами:
- State 0 → State 1
- State 1 → State 2 или State 3
- State 2 → State 0  
- State 3 → State 0

После изменений:
[![condvar1.png](https://i.postimg.cc/ncsjvH2m/condvar1.png)](https://postimg.cc/HVgkm1fW)

- `prodcons.c` — производитель/потребитель на condvar.

[![prodcons.png](https://i.postimg.cc/Wp7zgd0n/prodcons.png)](https://postimg.cc/4nmXTNL7)
