# Менеджер ресурсов

- В ОСРВ (QNX, VxWorks) предоставляет интерфейс файлов: open/read/write/ioctl через диспетчеризацию.
- На Linux аналог можно смоделировать сервером на UNIX-сокетах: `accept` ~ open, `recv` ~ read, `send` ~ write.
- Данные/состояние устройства хранятся в памяти сервера; можно ввести OCB/контекст сеанса в структуре потока.
- Безопасность: права на сокетный файл, валидация входных данных.
- Расширения: команды управления (простые текстовые или бинарные протоколы), неблокирующие режимы, poll/epoll.

## Дизайн протокола

- Простая текстовая схема: команды вида `CMD arg1 arg2...` с ответами `OK ...` или `ERR code`.
- Бинарная схема: фиксированные заголовки (тип, длина, версия) и полезная нагрузка.
- Необходимо учитывать фрагментацию/склейку TCP‑потоков (на UNIX‑сокетах тоже): использовать длину/разделители.

## Контекст соединения (OCB)

- Для каждого клиента можно хранить структуру: текущая позиция, права, буферы, тайм‑ауты.
- Для многопоточности: защищать общие структуры мьютексами; избегать долгих операций под блокировкой.

## Безопасность и тестирование

- Ограничить права на файл сокета (umask/`chmod`). Проверять длины и корректность входных данных.
- Тесты: позитивные (валидные команды) и негативные (ошибочные входы, разрывы).

Практика:

- `resmgr.c` — скелет сервера; студент добавляет протокол, состояние и обработку команд.
- `client.c` — простой клиент для проверки.

Здесь реализован менеджер ресурсов по аналогии с QNX но на Linux. Сервер создает UNIX-сокет и прослушивает подключения. Каждый новый клиент обслуживается в отдельном потоке.\
\
Реализовано виртуальное "устройство" - буфер в памяти с командами управления:
- READ - чтение данных из буфера
- DATA - запись текста в буфер  
- CLEAR - очистка буфера
- STATUS - статистика операций
- SET_ACCESS - смена прав доступа
- HELP - справка\
\
Все операции защищены мьютексом чтобы избежать гонки данных при одновременном доступе нескольких клиентов. Ведутся счетчики операций чтения и записи.\
\
Здесь показана работа клиента с менеджером ресурсов. Клиент отправляет команды и получает ответы. Видно что данные успешно записываются в буфер читаются из него. Все команды обрабатываются корректно.
[![client.png](https://i.postimg.cc/C5WFCnsS/client.png)](https://postimg.cc/64fJt3Pm)
\
Здесь видно что сервер успешно запущен и прослушивает сокет. Видны подключения клиентов каждый в отдельном потоке с уникальным файловым дескриптором. Сервер логирует все получаемые команды и отслеживает отключения клиентов.
[![resmgr.png](https://i.postimg.cc/131mf6z6/resmgr.png)](https://postimg.cc/9r15kDZF)
\
Реализован менеджер ресурсов по аналогии с QNX но на Linux. Сервер создает UNIX-сокет и прослушивает подключения. Каждый новый клиент обслуживается в отдельном потоке. Реализовано виртуальное устройство - буфер в памяти с командами управления READ DATA CLEAR STATUS SET_ACCESS HELP. Все операции защищены мьютексом чтобы избежать гонки данных при одновременном доступе нескольких клиентов. Ведутся счетчики операций чтения и записи. Система демонстрирует как в Linux можно эмулировать архитектуру менеджеров ресурсов из ОСРВ где каждый сервис представляется как устройство со стандартным интерфейсом операций.
