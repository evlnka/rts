# Теория: сигналы и таймеры (аналог прерываний)

- Сигналы: асинхронные уведомления процессу/потокам (SIGINT, SIGTERM, SIGUSR1/2). SIGKILL нельзя перехватить.
- Обработчики: должны быть короткими и использовать async-signal-safe функции (например, `write`). Общие флаги — тип `sig_atomic_t`.
- Таймеры: `setitimer(ITIMER_REAL)` генерирует SIGALRM периодически — аналог периодического прерывания таймера.
- Неблокирующий ввод: `termios` + `read` без ожидания для эмуляции событий ввода.

## Сигнальные маски и доставка

- Сигналы доставляются процессу; затем ядро выбирает поток‑получатель. Можно управлять маской сигналов через `pthread_sigmask`.
- Для поток‑направленных сигналов используйте `pthread_kill`.

## Таймеры и часы

- `ITIMER_REAL` зависит от реального времени (а не монотонного). Для более устойчивых интервалов в продакшене используйте POSIX‑таймеры с CLOCK_MONOTONIC (`timer_create`, `timer_settime`).

## Безопасность обработчиков

- Запрещены небезопасные функции (malloc, printf и т.п.). Используйте только async-signal-safe API.

Практика:

- `intsimple.c` — обработка сигналов и клавиш.

- Добавлена имитация сигналов через клавиатуру - клавиши c C 1 2 t T теперь генерируют соответствующие сигналы SIGINT SIGUSR1 SIGUSR2 SIGTERM с помощью функции raise

- Добавлена обработка условия выхода по получению SIGTERM - программа корректно завершается при получении этого сигнала

- Улучшены информационные сообщения - вывод теперь более подробно описывает тип обрабатываемого сигнала и его назначение\
\
Программа может демонстрировать работу с прерываниями как через внешние сигналы  так и через клавиатурные команды что удобно для тестирования и демонстрации

- `int.c` — периодический SIGALRM и счётчик событий.


